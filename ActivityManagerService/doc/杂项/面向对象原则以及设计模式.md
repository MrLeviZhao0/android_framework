# 面向对象原则以及设计模式

本文并不是深度解析各个原则和设计模式的，只有在实际的框架设计过程中会发现问题所在，从而通过框架的修改提升扩展性、鲁棒性等。

主要目的是记录面向对象的原则以及各出现的设计模式。

## 面向对象的六大原则

1. 单一职责原则：类只负责单独的职责，不要过多的处理其他的功能。
2. 开闭原则（对象对扩展开放，对修改是封闭的）：迭代的时候用只有错误的时候修改方法，其他时候都新增方法，调用新接口来调整功能。
3. 里氏替换原则：所有引用基类的地方必须能透明的使用其子类的对象。
4. 依赖倒置原则：1.高层模块不应该依赖底层模块，都依赖抽象。2.抽象不应该依赖细节。3.细节依赖抽象。
5. 接口隔离原则：客户端不应该依赖它不需要的接口，将臃肿的接口拆分成更小更具体的接口。
6. 迪米特原则（最少知识原则）：调用者或依赖者只关心跟他有关的内容，其他内容都不会暴露给他。

## 设计模式

这里举例25种设计模式，而且会简单的介绍一下。

1. [单例模式](#单例模式)
2. [Builder模式](#builder模式)
3. [原型模式](#原型模式)
4. [工厂模式](#工厂模式)
5. [策略模式](#策略模式)
6. [状态模式](#状态模式)
7. [责任链模式](#责任链模式)
8. [解释器模式](#解释器模式)
9. [命令模式](#命令模式)
10. [观察者模式](#观察者模式)
11. [备忘录模式](#备忘录模式)
12. [迭代器模式](#迭代器模式)
13. [模板方法模式](#模板方法模式)
14. [访问者模式](#访问者模式)
15. [中介者模式](#中介者模式)
16. [代理模式](#代理模式)
17. [组合模式](#组合模式)
18. [配适器模式](#配适器模式)
19. [装饰模式](#装饰模式)
20. [享元模式](#享元模式)
21. [外观模式](#外观模式)
22. [桥接模式](#桥接模式)
23. [MVC模式](#mvc模式)
24. [MVP模式](#mvp模式)

### 单例模式

单例模式是应用最广泛的模式之一，单例对象的类必须保证只有一个实例存在。这种不能自由构造对象的情况就是单例模式的使用场景。

**特点如下**：
1. 构造方法一般是private，不对外开放。
2. 通过一个静态方法或枚举返回单例对象。
3. 确保单例对象只有一个，特别是在多线程的情况下。
4. 确保单例对象在反序列化的情况下，不会新建对象。

**实现类型**：
1. 懒汉实现：
	1. 实现：声明静态对象，getInstance()函数被sychronized。
	2. 优点：只有被使用时才实例化，在一定程度上节约资源。
	3. 缺点：每次调用getInstance()都要同步，造成不必要开销。
2. Double Check Lock实现：
	1. 实现：双重判空mInstance，在两次判空之间锁Singleton.class。
	2. 优点：需要的时候初始化，且初始化后调用getInstance()不进行同步锁。
	3. 缺点：在JDK6以下会因为new操作的非原子性出问题，之后版本可以对mInstance添加volatile关键字。
3. 静态内部单例实现：
	1. 实现：静态私有内部类Holder持有static final变量sInstance，并初始化。getInstance返回的就是这个属性。
	2. 优点：第一次调用getInstance才会初始化，且对象唯一，线程安全。推荐使用的方法。
4. 枚举单例：实现简单。
5. 容器实现单例：利用容器管理单例。

**源码中的例子**：
1. Context。
2. LayoutInflater。

### Builder模式

Builder模式允许用户不知道内部细节的情况下，控制对象的构造流程，解耦类构造过程和部件。

**特点如下**：
1. 相同的方法，执行顺序不同，产生结果不同。
2. 多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果不同。
3. 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用Builder模式比较合适。
4. 当初始化一个对象非常复杂，参数多且还有默认值的时候。

**实现类型**：
1. 简单实现：
	1. 实现：实际实现中，多数是使用链式调用构造方法、参数设置、创建产品方法。如:`new TestBuilder().setA(A).create();`
	2. 优点：实现解耦，外部不知道更多具体细节的时候控制产品的构造。扩展性比较好。

**源码中的例子**：
1. AlertDialog.Builder。


### 原型模式

原型模式是用于创建一个新的实例，定制克隆的过程。原型模式一般用于创建复杂或者构造耗时的实例。

**特点如下**:
1. 类的初始化需要消耗非常多的资源，包括数据以及硬件。通过原型拷贝避免这些消耗。
2. 通过new产生一个对象需要非常繁琐的数据准备或者权限控制，这个时候可以用原型模式。
3. 一个对象需要提供给其他对象访问，各个调用者都需要修改其值，可以考虑用原型模式拷贝多个对象用于调用者使用。
4. 通过Cloneable实现原型模式的时候不一定比new快，只有new构造耗时时才会更快。

**实现类型**：
1. 浅拷贝
	1. 实现：实现Cloneable的clone接口，实现影子拷贝，实际上指向同一个地址。通过拷贝创建对象时，不会调用构造函数。
	2. 优点：效率高，但实际上有的时候需要的并不是浅拷贝。所以建议不是特别了解的情况用深拷贝。
2. 深拷贝
	1. 实现：创建新的对象，像Intent的clone()方法就是调用`new Intent(this)`。


**源码中的例子**：
1. Intent。


### 工厂模式

工厂方法模式就是抽象，然后实现函数。抽象工厂模式就是抽象类，子类继承，然后统一调用接口。

**特点如下**:常见，略。

**实现类型**：
1. 简单工厂：没啥用。
2. 工厂方法：基本概念。
3. 抽象工厂：常用的一种模式，实现工厂父类，再实现具体工厂。

**源码中的例子**：
1. 工厂方法模式：Activity的onCreate等。
2. 抽象工厂模式：Royole语音项目语音引擎模块。


### 策略模式

策略模式把策略封装起来，继承同一个接口，使具体的算法变化与用户独立。其实这个也就是接口的一种使用方式。

**特点如下**:
1. 针对同一类型的问题有多种解决方案。
2. 需要安全的封装多种同一类型的操作时。
3. 出现同一个抽象类有多个子类，需要用if-else选择子类时。

**实现类型**：把子类传到以父类为参数的函数中，调用子类的功能。

**源码中的例子**：
1. 动画中的时间插值器TimeInterpolator，预设的有LinearInterpolator、AccelerateDecelerateInterpolator等。


***
emmm，写到这里暂时不想继续写下去了，设计模式更多的时候需要结合项目的具体架构设计，光是简单的描述设计模式的定义其实没有太多意义。java面向对象思想需要深刻理解的话，纸上学来终觉浅，绝知此事要躬行。


