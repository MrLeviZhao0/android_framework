# 编译系统 #

转自博客：[编译系统](http://blog.csdn.net/lizekun2010/article/details/52598105)

## make流程 ##

### 编译入口 ### 

当我们在Android源码根目录下执行make的时候，会查找当前目录下的Makefie文件或者makefile文件并且执行，在android/Makefile文件中，它只有一行有用的内容：

```
1 ### DO NOT EDIT THIS FILE ###  
2 include build/core/main.mk  
3 ### DO NOT EDIT THIS FILE ###  
```

### 整体依赖 ###

我们在Android源码根目录下执行make命令的时候，并没有传入目标，那么就会执行默认的目标。那默认的目标是什么呢？在android/build/core/main.mk中有这样几行：

```
63 # This is the default target.  It must be the first declared target.  
64 .PHONY: droid  
65 DEFAULT_GOAL := droid  
66 $(DEFAULT_GOAL): droid_targets  
```
从63行注释可以看出，默认编译的就是droid这个伪目标，make工具遇到伪目标以后，会检查解析伪目标的依赖，如果伪目标存在依赖，就会检查这些依赖，如果这些依赖是伪目标，就继续检查这个伪目标的依赖，如果不是伪目标，就会生成这个目标，如此一层一层递归下去。



另外，在android/build/core/main.mk中还有这样几行：

```
1046 # Building a full system-- the default is to build droidcore  
1047 droid_targets: droidcore dist_files  
```
这就说明droid这个伪目标依赖droidcore和dist_files两大部分（整体编译时TARGET_BUILD_APPS为空），然后再将这两个依赖逐步解析下去，可以得到编译droid的整体依赖关系如下图：

[整体依赖](./整体依赖.png)

有必要说明两点：

1）有些依赖（比如INSTALLED_BOOTIMAGE_TARGET）在android/build/core/main.mk中没有定义，而是在android/build/core/Makefile中定义的；

2）上面dist_files也是个伪目标，并且它没有任何依赖，利用dist-for-goals方法来拷贝库文件，可忽略。

### 编译主流程 ###

main.mk -> config.mk -> envsetup.mk -> product_config.mk

接着回到android/build/core/envsetup.mk中，include了板型配置文件BoardConfig.mk

上述过程是定制化产品配置的读取过程。首选要通过lunch选择产品，这个时候产品的路径就会被导入。config等文件就是特定的device目录下的文件。

### 加载所有模块 ###

加载完板型配置信息后，回到main.mk文件中，很快发现了ONE_SHOT_MAKEFILE的使用。如果这个变量被定义了，那么就是编译一个模块，如果没有被定义，就说明是编译整个系统。MAKECMDGOALS是make的一个环境变量，当我们执行make的时候并没有设置它，因此它为空。所以dont_bother不等于true，因此会加载所有的Android.mk，这里是调用一个python脚本android/build/tools/findleaves.py来查找系统中所有的Android.mk，然后循环include进来：

```
542 # Include all of the makefiles in the system  
543 #  
544  
545 # Can't use first-makefiles-under here because  
546 # --mindepth=2 makes the prunes not work.  
547 subdir_makefiles := \  
548     $(shell build/tools/findleaves.py $(FIND_LEAVES_EXCLUDES) $(subdirs) Android.mk)  
549  
550 ifeq ($(USE_SOONG),true)  
551 subdir_makefiles := $(SOONG_ANDROID_MK) $(call filter-soong-makefiles,$(subdir_makefiles))  
552 endif  
553  
554 $(foreach mk, $(subdir_makefiles),$(info including $(mk) ...)$(eval include $(mk)))  //这里循环include进来  
```

### JACK调用 ###

此处，我们不分析如何调用JACK，如果想知道更多的内容，可以参考文章开头链接。

我们这里主要讲的是如何禁用JACK以及oat加速。

### 如何禁用JACK以及oat加速 ###

以下是Android.mk中可以设置的变量。

1. LOCAL_JACK_ENABLED

这个变量可以禁止使用Jack编译工具链编译该模块。

禁止方法如下：

```
LOCAL_JACK_ENABLED := disabled  
```

2. LOCAL_DEX_PREOPT
这个变量设置为false可以使整个系统使用提前优化的时候，某个app不使用提前优化。在Android.mk中给该变量赋值为false,则编译生成的文件没有oat文件，也就意味着没有被提前优化。

```
LOCAL_DEX_PREOPT := false  
```

3. WITH_DEXPREOPT
这个变量的使能导致system image中的所有东西都被提前优化（pre-optimized）。这可能导致system image非常大。

```
WITH_DEXPREOPT := true  
```

4. DONT_DEXPREOPT_PREBUILTS

```
WITH_DEXPREOPT := true  
DONT_DEXPREOPT_PREBUILTS := true  
```

这两个组合使用，可以使那些 prebuild的app不会被提前优化（pre-optimized）,即就是那些在Android.mk中包含intclude $(BUILD_PREBUILT)的app都不会被提前优化

5. WITH_DEXPREOPT_BOOT_IMG_ONLY

```
WITH_DEXPREOPT := true  
WITH_DEXPREOPT_BOOT_IMG_ONLY := true 
``` 

这两个组合使用只会优化boot image。


在编译时，如果希望整体能禁用的话，以下是整体禁用oat加速：

/device/company/product/BoardConfig.mk

```
# Enable dex-preoptimization to speed up first boot sequence
ifeq ($(HOST_OS),linux)
  ifneq ($(TARGET_BUILD_VARIANT),eng)
    ifeq ($(WITH_DEXPREOPT),)
      WITH_DEXPREOPT := true  修改属性false即可。
    endif
  endif
endif
```

这里可以修改默认属性，JACK编译应该同理，但还未验证。
